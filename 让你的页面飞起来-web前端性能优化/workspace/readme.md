Web前端本质上是一种GUI软件

## DNS层面：可以做缓存，可以在浏览器层面、甚至路由器层面将DNS服务器相关的信息做缓存，这样可以将访问DNS的时间缩短很多。

## 网络请求：网络请求涉及到带宽、网络选择，涉及到缓存。可以使用CDN做优化

CDN：CDN是访问静态资源用的，对于静态资源来说，请求中携带的cookie是没有用的，所以我们希望请求静态资源时，可以将cookie从请求头中去掉，因此CDN域名不要与主站域名一样，这样可以防止访问CDN时携带主站的cookie。CDN可以解决网络选择、缓存以及静态资源的问题，但是对于一些接口，我们是没有办法使用CDN的，那么对于这样的接口，我们能否做一些缓存呢，实际上除了CDN，我们还可以在浏览器端做一些缓存策略。通过浏览器端的缓存策略，我们对于一些相同的资源和一些相同的接口，就可以去浏览器的缓存中读取数据。这样我们的访问速度又得到了一些提升。除了缓存和路径选择，带宽也是非常重要的一点，http请求的大小如果小一些，请求的速度也会相对快一些。如何减小http请求的大小，也是整个请求过程中非常重要的一点。另外，每一个网络请求都会从我们的网络层到达服务器，每次请求都会有网络的损耗，我们能否将多次网络请求合并成一次，从而减少网络损耗。

对于一些大型框架，比如vue、react，他们的模板都是在浏览器端进行渲染的，不是直出的html，而是要走框架中相关的框架代码，才能去渲染出页面，那么这个渲染过程对于首屏就会有很大的损耗，这个是不利于前端性能的，这种情况下我们业界就会经常使用一些相关框架的服务端渲染的方案。在服务端进行整个HTML的渲染，从而将整个HTML直出到浏览器端，而不是在浏览器端进行渲染，所以在渲染之前，我们也可以做一些服务端渲染以及渲染优化的方案。

## 文件压缩：HTML压缩(html-minifier)，css压缩(clean-css)，js压缩(uglify-js）

## 文件合并

不合并请求存在的问题：
1. 文件与文件之间有插入的上行请求，增加n-1个网络请求（网络延迟）；
2. 丢包问题更加严重，因为每次网络请求都可能存在丢包的情况，每次丢包情况都会影响相关js的获取；
3. keep alive这种方式也有自身的问题。它经过代理服务器的时候，很可能是会被断开的，就是说不一定能完成keep alive状态的保存。

合并存在问题：
1. 首屏渲染的问题。合并之后的js显然会比较大，如何页面的显然依赖js的话，整个页面的渲染要等到js被请求回来之后才能进行，如果这个js文件比较大，它请求的速度比较慢的话，这个时候就会导致首屏渲染的问题出现，首屏渲染会延迟到整个大的合并后的文件的请求回来之后才执行。
2. 缓存失效的问题。因为js是有缓存的，我们在标记这个js是否被更改的时候，会在js之后加个md5戳，那这个md5戳就是个唯一标识这个js文件改变的，如果多个文件合并为一个文件，那任意一个文件的改变都会导致整个合并后的js有变动，就会导致合并后的js的缓存失效。而如果没有合并的话，单个文件的修改，只会造成该文件部分的js文件缓存失效，不会造成大面积的缓存失效。这就是文件合并会导致缓存大面积失效的问题。这也是我们在选择是否进行文件合并时需要重点考量的点。

1. 公共库合并：公共库单独打包成一个文件，业务代码单独打包一个文件，我们改动业务代码时不会影响公共库的缓存。
2. 不同页面的：这个是针对单页应用的，对单页应用来说，它一开始页面渲染的时候，它会请求当前这个页面所对应的js，而不是将整个单页应用所有的js都打成一个包直接请求回来。这显然是不合理的。在真实的业务场景中，我们是希望单页应用中的某一个页面被路由到的时候，我们才去加载那个页面的组件，才去请求那个页面的js。这样我们实际需要做的就是将不同页面的js进行分别打包。当我们前端路由，路由到哪个页面的时候，我们才去加载那个页面的组件，才去加载那个页面所对应的js文件。这种方式实际上，在webpack或者说在fis这样的构建工具层面，都是可以实现的。就是异步加载组件结合现在的框架都有很好的实现方式。

## 图片优化

## 浏览器渲染机制

### HTML 页面加载渲染的过程

### css阻塞和js阻塞

## 懒加载与预加载

懒加载：监听scroll事件，判断图片是否进入可视窗口

预加载：

1. img 设置 src 设置 display:none;
2. 使用Image对象 设置src
3. 使用XMLHTTPRequest  open一个image资源  判断请求状态 然后在回调中处理  存在跨越问题   但是可以控制加载过程


## 重绘与回流

重绘：元素外观变化

回流：涉及到元素大小或布局变化

回流一定会引起重绘 重绘不一定回流

触发页面重布局的属性

1.translate替换top  top会触发页面layout，top不会
2.用opacity替换visibility
3.不要一条一条修改DOM
4.把DOM离线后修改

## 浏览器存储

Cookie、LocalStorage、SessionStorage、IndexDB

Service Worker

PWA   GoogleChrome/lighthouse

## 缓存

httpheader

Cache-Control/Expires

Expires 优先级低于Cache-Control中的max-age

Last-Modified
If-Modified-Since

Etag/If-None-Match

## SSR